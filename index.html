<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>ðŸ’¨ FartCoin Dash</title>
  <style>
    /* --- Base Styles --- */
    html,body {
      margin: 0;
      padding: 0;
      background: #0d1417;
      overflow: hidden;
      font-family: system-ui, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    #game-container {
      position: relative;
      width: 100%;
      max-width: 400px;
      height: 100vh;
      max-height: 800px;
      aspect-ratio: 9 / 16;
      background: #000;
      border-radius: 20px;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
    }
    #overlay {
      position: absolute;
      top: 0; left: 0; right: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(0,0,0,0.5);
      color: #fff;
      padding: 10px;
      z-index: 10;
      font-size: 14px;
    }
    button {
      background: #39f87c;
      color: #022410;
      font-weight: 700;
      border: none;
      border-radius: 5px;
      padding: 6px 10px;
      cursor: pointer;
    }
    #errorLog {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      max-height: 100px;
      overflow-y: scroll;
      background: rgba(255, 0, 0, 0.7);
      color: white;
      font-family: monospace;
      font-size: 12px;
      padding: 5px;
      z-index: 9999;
      display: none; /* Hide by default */
    }

    /* --- Gemini Modal Styles --- */
    #modalOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: none; /* Hidden by default */
      justify-content: center;
      align-items: center;
      z-index: 1000;
      padding: 20px;
      box-sizing: border-box;
    }
    #modalBox {
      background: #1a202c;
      color: white;
      padding: 24px;
      border-radius: 12px;
      text-align: center;
      width: 90%;
    }
    #modalBox h2 {
      margin: 0 0 10px;
      color: #39f87c;
    }
    #modalBox p {
      margin: 0 0 20px;
      font-size: 1.1rem;
    }
    #modalBox #aiResult {
      font-style: italic;
      color: #a0aec0;
      min-height: 50px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #modalBox .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #39f87c;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 10px auto;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    #modalBox button {
      width: 100%;
      padding: 12px;
      font-size: 1rem;
      margin-top: 20px;
    }
  </style>
  <!-- Load LittleJS Engine -->
  <script src="https://unpkg.com/littlejsengine@latest/dist/littlejs.min.js"></script>
</head>
<body>
  
  <div id="game-container">
    <div id="overlay">
      <div>ðŸ’¨ <b>FartCoin Dash</b></div>
      <div><button id="startBtn">Start</button></div>
    </div>
    <!-- Error log is now hidden by default -->
    <div id="errorLog"></div>
  </div>

  <!-- Gemini Modal HTML -->
  <div id="modalOverlay">
    <div id="modalBox">
      <h2>Game Over!</h2>
      <p>Your Score: <span id="finalScore">0</span></p>
      <div id="aiResult">
        <div class="spinner"></div>
      </div>
      <button id="playAgainBtn">Play Again</button>
    </div>
  </div>

  <!-- *** ALL GAME.JS CODE IS PASTED IN HERE *** -->
  <script>
    /*
     * FartCoin Dash - All-in-One Version
     * - FIX: Added default texture sheet to engineInit to fix rendering.
     * - FIX: Moved "Press Start" text to be visible.
     */

    // --- Helper function to print to the screen ---
    function logToHTML(message, isError = false) {
      try {
        const errorLog = document.getElementById('errorLog');
        if (errorLog) {
          // Un-hide the log if there's an error
          if(isError) {
            errorLog.style.display = 'block';
          }
          const entry = document.createElement('div');
          entry.textContent = message;
          if (isError) {
            entry.style.color = 'yellow';
            entry.style.fontWeight = 'bold';
          }
          errorLog.appendChild(entry);
          errorLog.scrollTop = errorLog.scrollHeight; 
        }
      } catch(e) { /* failsafe */ }
    }

    // --- Global Error Catcher ---
    window.onerror = function(message, source, lineno, colno, error) {
      logToHTML(`ERROR: ${message} (line ${lineno})`, true);
      return true;
    };

    // --- SCRIPT EXECUTION STARTS HERE ---
    try {
      // Game Objects
      let player, coins = [], clouds = [];
      let score = 0, timeLeft = 60, running = false;
      let sCoin, sHit;
      const WORLD_SIZE = 15;

      const modalOverlay = document.getElementById('modalOverlay');
      const finalScoreEl = document.getElementById('finalScore');
      const aiResultEl = document.getElementById('aiResult');
      const playAgainBtn = document.getElementById('playAgainBtn');

      function gameInit() {
        try {
          cameraPos = vec2(0, 0);
          cameraScale = 35; 

          player = new EngineObject(vec2(0, 0), vec2(1, 1));
          player.color = new Color(0, 1, 0);

          sCoin = new Sound([0,,0.2,,0.15,0.3,,0.3,,0.1]);
          sHit = new Sound([0,,0.15,,0.3,0.25,,0.2,,0.2]);

        } catch (e) {
          logToHTML(`Error in gameInit: ${e.message}`, true);
        }
      }

      function spawnCoin() {
        const coin = new EngineObject(randInCircle(vec2(0,0), WORLD_SIZE), vec2(0.6, 0.6));
        coin.color = new Color(1, 1, 0);
        coin.type = 'coin';
        coins.push(coin);
      }

      function spawnCloud() {
        const c = new EngineObject(randInCircle(vec2(0,0), WORLD_SIZE), vec2(1.2, 1.2));
        c.color = new Color(0.8, 0.8, 0.8);
        c.type = 'cloud';
        c.velocity = randInCircle(vec2(0,0), 0.015);
        clouds.push(c);
      }

      function resetGame() {
        try {
          coins = [];
          clouds = [];
          score = 0;
          timeLeft = 60;
          running = true;
          player.pos = vec2(0,0);
          for (let i = 0; i < 8; i++) spawnCoin();
          for (let i = 0; i < 4; i++) spawnCloud();
        } catch (e) {
          logToHTML(`Error in resetGame: ${e.message}`, true);
        }
      }

      function gameUpdate() {
        if (!running) return;

        const speed = 0.07;
        const move = vec2(
          (keyIsDown(39) || keyIsDown(68)) - (keyIsDown(37) || keyIsDown(65)),
          (keyIsDown(38) || keyIsDown(87)) - (keyIsDown(40) || keyIsDown(83))
        );
        player.pos = player.pos.add(move.scale(speed));

        coins.forEach(c => {
          if (player.pos.distance(c.pos) < 1) {
            score += 10;
            sCoin.play();
            c.pos = randInCircle(vec2(0,0), WORLD_SIZE);
          }
        });

        clouds.forEach(c => {
          c.pos = c.pos.add(c.velocity);
          if (Math.abs(c.pos.x) > WORLD_SIZE || Math.abs(c.pos.y) > WORLD_SIZE)
            c.velocity = c.velocity.neg();
          if (player.pos.distance(c.pos) < 1) {
            score = Math.max(0, score - 15);
            sHit.play();
          }
        });

        timeLeft -= timeDelta;
        if (timeLeft <= 0) {
          running = false;
          showEndGameModal(score);
        }
      }

      function gameUpdatePost() {}

      function gameRender() {
        const scorePos = vec2(-cameraScale * 0.4, cameraScale * 0.45);
        const timePos = vec2(cameraScale * 0.2, cameraScale * 0.45);

        drawText(`Score: ${score}`, scorePos, 1.2, new Color(0,1,0));
        drawText(`Time: ${Math.ceil(timeLeft)}`, timePos, 1.2, new Color(1,1,1));

        if (!running) {
          // *** FIX: Moved text up so it's not hidden by the player ***
          drawTextCentered('Press Start', vec2(0,2), 2, new Color(1,1,1));
        }
      }

      function gameRenderPost() {}

      function drawTextCentered(text, pos, size = 1, color = new Color(1,1,1)) {
        const width = text.length * size * 0.6;
        drawText(text, vec2(pos.x - width / 2, pos.y), size, color);
      }

      // --- Gemini API Functions ---
      function showEndGameModal(finalScore) {
        finalScoreEl.textContent = finalScore;
        aiResultEl.innerHTML = '<div class="spinner"></div>'; 
        modalOverlay.style.display = 'flex';

        callGemini(finalScore)
          .then(response => {
            aiResultEl.textContent = `"${response}"`; 
          })
          .catch(err => {
            logToHTML(`Gemini API Error: ${err.message}`, true);
            aiResultEl.textContent = "Couldn't get AI analysis. Play again!";
          });
      }

      async function callGemini(score, retries = 3, delay = 1000) {
        const apiKey = ""; 
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        const systemPrompt = "You are a witty, slightly rude game announcer for a silly game called 'FartCoin Dash'. Your job is to give the player a one-sentence, fart-themed, funny remark based on their final score. Be creative, concise, and stay in character.";
        const userQuery = `My final score was ${score}. Give me a one-sentence roast or congratulations.`;

        const payload = {
          contents: [{ parts: [{ text: userQuery }] }],
          systemInstruction: {
            parts: [{ text: systemPrompt }]
          },
        };

        try {
          const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.statusText}`);
          }

          const result = await response.json();
          const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

          if (text) {
            return text;
          } else {
            throw new Error("Invalid response structure from API.");
          }
        } catch (error) {
          logToHTML(`Gemini API fetch error: ${error.message}`, true);
          if (retries > 0) {
            await new Promise(res => setTimeout(res, delay));
            return callGemini(score, retries - 1, delay * 2); 
          } else {
            throw error;
          }
        }
      }

      // --- Attach button listeners ---
      document.getElementById('startBtn').onclick = () => {
        resetGame();
      };

      playAgainBtn.onclick = () => {
        modalOverlay.style.display = 'none';
        resetGame();
      };

      // *** THE FIX: The texture sheet URL must be in an array ***
      engineInit(
        gameInit, 
        gameUpdate, 
        gameUpdatePost, 
        gameRender, 
        gameRenderPost,
        ['https://unpkg.com/littlejsengine@latest/dist/engine/littlejs.png']
      );

    } catch (e) {
      logToHTML(`Critical Script Error: ${e.message}`, true);
    }
  </script>
</body>
</html>

